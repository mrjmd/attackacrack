# This is the specification for the Attack-a-Crack application on Digital Ocean App Platform.
# Version 3: Corrected syntax for worker and database components.

name: attackacrack-prod

# Define the region for your app. Choose one close to your users.
# e.g., nyc3, sfo3, ams3, sgp1, fra1
region: nyc3

# Define the services (public-facing web containers) for your application.
services:
  - name: attackacrack-web
    # Use pre-built image from DigitalOcean Container Registry
    # The deploy workflow will update this with the correct tag
    image:
      registry_type: DOCR
      repository: attackacrack-crm
      tag: main
    # Define the command to run the web server.
    # This overrides the Dockerfile's CMD or ENTRYPOINT for this specific service.
    # We use gunicorn for a production-ready WSGI server.
    run_command: ./entrypoint.sh
    # Define the instance size. Start with the smallest and scale up as needed.
    instance_size_slug: basic-xxs
    # Define the number of instances. Start with 1 and enable auto-scaling.
    instance_count: 1
    # Define the HTTP port the application listens on inside the container.
    http_port: 5000
    # Define the routes for incoming traffic.
    routes:
      - path: /
    # CRITICAL: Health checks for production readiness.
    # The App Platform will hit this endpoint to ensure the container is healthy.
    # If this fails, the deployment will be rolled back.
    health_check:
      http_path: /health # We must create this route in our Flask app.
    # Define environment variables.
    # Secrets like SECRET_KEY, OPENPHONE_API_TOKEN, etc., should be set in the App Platform UI.
    envs:
      - key: FLASK_ENV
        value: "production"
      - key: FLASK_APP
        value: "app.py"
      - key: DATABASE_URL
        # This special syntax binds the connection string from the managed database.
        value: ${db.DATABASE_URL}
      - key: POSTGRES_URI
        # Also set POSTGRES_URI to the same value for compatibility
        value: ${db.DATABASE_URL}
      # IMPORTANT: Environment variables must be set in DigitalOcean UI
      # They will be preserved across deployments if not defined here

# Define the workers (background task processors) for your application.
workers:
  - name: attackacrack-worker
    # Use pre-built image from DigitalOcean Container Registry
    image:
      registry_type: DOCR
      repository: attackacrack-crm
      tag: main
    # Define the command to run the Celery worker.
    # Limit concurrency to 2 workers for basic-xxs instance
    run_command: celery -A celery_worker.celery worker --loglevel=info --concurrency=2
    # Define the instance size - xs for worker to handle memory requirements
    instance_size_slug: basic-xs
    # Define the number of instances.
    instance_count: 1
    # Define environment variables (must match the web service).
    envs:
      - key: FLASK_ENV
        value: "production"
      - key: FLASK_APP
        value: "app.py"
      - key: DATABASE_URL
        value: ${db.DATABASE_URL}
      - key: POSTGRES_URI
        value: ${db.DATABASE_URL}
      # Environment variables must be set through the DigitalOcean UI

# Define the managed databases and other addons for the application.
databases:
  - name: db
    # Use PostgreSQL version 13.
    engine: PG
    version: "13"
    # The production database name will be auto-created as 'db'
    # matching the component name
    production: true
    # Cluster name for the production database
    cluster_name: attackacrack-db
    # The size of the database cluster. Start small.
    size: db-s-1vcpu-1gb
